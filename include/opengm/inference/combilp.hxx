/*
 * combiLP.hxx
 *
 *  Created on: Sep 16, 2013
 *  Author: bsavchyn
 */

#ifndef OPENGM_COMBILP_HXX
#define OPENGM_COMBILP_HXX

// To enable detailed debug output enable the following preprocessor macro:
// #define OPENGM_COMBILP_DEBUG
//
// FIXME: The above macro should be a parameter!
#define OPENGM_COMBILP_DEBUG

#include <boost/scoped_ptr.hpp>

#include <opengm/graphicalmodel/graphicalmodel_manipulator.hxx>
#include <opengm/inference/lpcplex.hxx>
#include <opengm/inference/auxiliary/lp_reparametrization.hxx>
#include <opengm/inference/trws/output_debug_utils.hxx>
#include <opengm/inference/trws/trws_base.hxx>

namespace opengm{

namespace combilp {
	template<class GM>
	void dilateMask(const GM &, typename GM::IndexType, std::vector<bool>&);

	template<class GM>
	void dilateMask(const GM&, std::vector<bool>&);

	template<class GM>
	bool LabelingMatching(const std::vector<typename GM::LabelType>&,const std::vector<typename GM::LabelType>&, const std::vector<bool>&, std::vector<typename GM::IndexType>&);

	template<class GM>
	bool LabelingMatching(const GM&, const std::vector<typename GM::LabelType>&, const std::vector<typename GM::LabelType>&, const std::vector<bool>&, std::vector<typename GM::IndexType>&, typename GM::ValueType&);

	template<class GM>
	void getMaskBoundary(const GM&, const std::vector<bool>&, std::vector<bool>&);
}

template<class LP>
struct CombiLP_ILP_TypeGen
{
	typedef typename GraphicalModelManipulator<
		typename LP::ReparametrizerType::ReparametrizedGMType
	>::MGM
	GraphicalModelType;
};

////////////////////////////////////////////////////////////////////////////////
//
// class CombiLP
//
////////////////////////////////////////////////////////////////////////////////

//
// The LP solver template argument should be an inference algorithm working on
// the original GrahpicalModel GM.
//
// The ILP solver template argument should be an inference algorithm working on
// an auxiliary GraphicalModel. The auxiliary type can be generated by using
// the type generator CombiLP_ILP_TypeGen<LPSOLVER>::GraphicalModelType.
//
// Example usage:
//
// typedef TRWSi<GM, ACC> LPSOLVER;
// typedef typename CombiLP_ILP_TypeGen<LPSOLVER>::GraphicalModelType GM_AUX;
// typedef LPCplex<GM_AUX ,ACC> ILPSOLVER;
//
// typedef CombiLP<GM, ACC, LPSOLVER, ILPSOLVER> Inference;
// Inference inf(gm);
// inf.infer();
// [...]
//

/// \brief CombiLP\n\n
/// Savchynskyy, B. and Kappes, J. H. and Swoboda, P. and Schnoerr, C.:
/// "Global MAP-Optimality by Shrinking the Combinatorial Search Area with Convex Relaxation".
/// In NIPS, 2013.
/// \ingroup inference
template<class GM, class ACC, class LP, class ILP>
class CombiLP : public Inference<GM, ACC>
{
public:
	//
	// Types
	//
	typedef ACC AccumulationType;
	typedef GM GraphicalModelType;
	typedef LP LPSolverType;
	typedef ILP ILPSolverType;
	OPENGM_GM_TYPE_TYPEDEFS;
	typedef std::vector<LabelType> Labeling;

	typedef visitors::VerboseVisitor< CombiLP<GM, ACC, LP, ILP> > VerboseVisitorType;
	typedef visitors::EmptyVisitor< CombiLP<GM, ACC, LP, ILP> > EmptyVisitorType;
	typedef visitors::TimingVisitor< CombiLP<GM, ACC, LP, ILP> > TimingVisitorType;

	typedef typename LPSolverType::ReparametrizerType ReparametrizerType;
	typedef typename ReparametrizerType::MaskType MaskType;
	typedef GraphicalModelManipulator<typename ReparametrizerType::ReparametrizedGMType> ManipulatorType;

	struct Parameter
	{
		typedef typename LPSolverType::Parameter LPParameterType;
		typedef typename ILPSolverType::Parameter ILPParameterType;
		typedef typename ReparametrizerType::Parameter RepaParameterType;

		Parameter
		(
			LPParameterType lpsolverParameter = LPParameterType(),
			RepaParameterType repaParameter = RepaParameterType(),
			ILPParameterType ilpsolverParameter = ILPParameterType(),
			size_t maxNumberOfILPCycles = 100,
			bool verbose = false,
			std::string reparametrizedModelFileName = "",
			bool singleReparametrization = true,
			bool saveProblemMasks = false,
			std::string maskFileNamePre = "",
			size_t threads = 1
		)
		: maxNumberOfILPCycles_(maxNumberOfILPCycles)
		, verbose_(verbose)
		, reparametrizedModelFileName_(reparametrizedModelFileName)
		, singleReparametrization_(singleReparametrization)
		, saveProblemMasks_(saveProblemMasks)
		, maskFileNamePre_(maskFileNamePre)
		, threads_(threads)
		{
		}

		size_t maxNumberOfILPCycles_;
		bool verbose_;
		std::string reparametrizedModelFileName_;
		bool singleReparametrization_;
		bool saveProblemMasks_;
		std::string maskFileNamePre_;
		size_t threads_;

		LPParameterType lpsolverParameter_;
		ILPParameterType ilpsolverParameter_;
		RepaParameterType repaParameter_;

#ifdef OPENGM_COMBILP_DEBUG
		void
		print() const
		{
			std::cout << "maxNumberOfILPCycles=" << maxNumberOfILPCycles_ << std::endl;
			std::cout << "verbose" << verbose_ << std::endl;
			std::cout << "reparametrizedModelFileName=" << reparametrizedModelFileName_ << std::endl;
			std::cout << "singleReparametrization=" << singleReparametrization_ << std::endl;
			std::cout << "saveProblemMasks=" << saveProblemMasks_ << std::endl;
			std::cout << "maskFileNamePre=" << maskFileNamePre_ << std::endl;
			std::cout << "== lpsolverParameters: ==" << std::endl;
			lpsolverParameter_.print(std::cout);
		}
#endif
	};

	//
	// Methods
	//
	CombiLP(const GraphicalModelType& gm, const Parameter& param);
	std::string name() const{ return "CombiLP"; }
	const GraphicalModelType& graphicalModel() const { return gm_; }

	InferenceTermination infer();
	template<class VISITOR> InferenceTermination infer(VISITOR&);
	InferenceTermination arg(Labeling &out, const size_t = 1) const;
	ValueType bound() const { return bound_; }
	ValueType value() const { return value_; }

private:
	//
	// Methods
	//
	void performLP();
	template<class VISITOR> InferenceTermination performILP(VISITOR&);

	InferenceTermination PerformILPInference_(ManipulatorType& modelManipulator, std::vector<LabelType> &plabeling);

	//
	// Members
	//
	Parameter parameter_;
	GraphicalModelType gm_;
	LPSolverType lpsolver_;
	boost::scoped_ptr<ReparametrizerType> reparametrizer_;
	std::vector<LabelType> labeling_;
	ValueType value_;
	ValueType bound_;
	MaskType mask_;

	// NOTE: We need the lpsolver_ only during performLP() phase. The problem
	// is that the ILP steps in performILP() also need the reparametrizer.
	// We just reuse the same reparametrizer. But the reparametrizer accesses
	// pointers which refer te lpsolver_.
	//
	// TODO: Should be possible to separate lpsolver and reparametrizer more?
	// Then we could maybe also just create a new reparametrizer in the ILP
	// phase? (If we do not need the stored reparametrized configuration
	// anymore, do not know if this is the case...)
};

template<class GM, class ACC, class LP, class ILP>
CombiLP<GM, ACC, LP, ILP>::CombiLP
(
	const GraphicalModelType& gm,
	const Parameter& param
)
: parameter_(param)
, gm_(gm)
, lpsolver_(gm_, parameter_.lpsolverParameter_)
, reparametrizer_(lpsolver_.getReparametrizer(parameter_.repaParameter_))
, labeling_(gm.numberOfVariables(),std::numeric_limits<LabelType>::max())
, value_(ACC::template neutral<ValueType>())
, bound_(ACC::template ineutral<ValueType>())
{
#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Parameters of the " << name() << " algorithm:" << std::endl;
	param.print();
#endif
};

template<class GM, class ACC, class LP, class ILP>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::infer()
{
	EmptyVisitorType visitor;
	return infer(visitor);
};

template<class GM, class ACC, class LP, class ILP>
template<class VISITOR>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::infer
(
	VISITOR &visitor
)
{
	visitor.begin(*this);
	performLP();

	// FIXME: initialmask is not available here
	if ( (visitor(*this) != visitors::VisitorReturnFlag::ContinueInf) ||
	     (std::count(mask_.begin(), mask_.end(), false) == 0) )
	{
		visitor.end(*this);
		return NORMAL;
	}

	InferenceTermination result = performILP(visitor);
	visitor.end(*this);
	return result;
}

template<class GM, class ACC, class LP, class ILP>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::arg(
	Labeling& labeling,
	const size_t idx
) const
{
	if (idx != 1)
		return UNKNOWN;

	labeling = labeling_;
	return NORMAL;
}

//
// TODO: Clean this method.
//
template<class GM, class ACC, class LP, class ILP>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::PerformILPInference_
(
	ManipulatorType& modelManipulator,
	Labeling& plabeling
)
{
	InferenceTermination terminationILP=NORMAL;
	modelManipulator.buildModifiedSubModels();

	std::vector<Labeling> submodelLabelings(modelManipulator.numberOfSubmodels());
	for (size_t modelIndex=0; modelIndex < modelManipulator.numberOfSubmodels(); ++modelIndex) {
		const typename ManipulatorType::MGM& model = modelManipulator.getModifiedSubModel(modelIndex);
		submodelLabelings[modelIndex].resize(model.numberOfVariables());
		ILPSolverType ilpSolver(model, parameter_.ilpsolverParameter_);
		terminationILP=ilpSolver.infer();

		if ((terminationILP!=NORMAL) && (terminationILP!=CONVERGENCE)) {
			return terminationILP;
		} else {
			ilpSolver.arg(submodelLabelings[modelIndex]);
		}
	}

	modelManipulator.modifiedSubStates2OriginalState(submodelLabelings, plabeling);

	return terminationILP;
}

template<class GM, class ACC, class LP, class ILP>
void
CombiLP<GM, ACC, LP, ILP>::performLP()
{
#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Running LP solver "<< lpsolver_.name() << std::endl;
#endif

	lpsolver_.infer();
	value_ = lpsolver_.value();
	bound_ = lpsolver_.bound();
	lpsolver_.arg(labeling_);
	lpsolver_.getTreeAgreement(mask_);

#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Energy of the labeling consistent with the arc consistency =" << lpsolver_.graphicalModel().evaluate(labeling_) << std::endl;
	std::cout << "Arc inconsistent set size =" << std::count(mask_.begin(),mask_.end(),false) << std::endl;
	std::cout << "Trivializing." << std::endl;
#endif

#ifdef WITH_HDF5
	if (parameter_.reparametrizedModelFileName_.compare("") != 0) {
#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "Saving reparametrized model..." << std::endl;
#endif
		typename ReparametrizerType::ReparametrizedGMType gm;
		// TODO: Check this! Why another mask?
		// FIXME: Looks bogous.
		MaskType mask(reparametrizer_->graphicalModel().numberOfVariables(), true);
		reparametrizer_->reparametrize(&mask);
		reparametrizer_->getReparametrizedModel(gm);
		store_into_explicit(gm, parameter_.reparametrizedModelFileName_);
	}
#endif

	trws_base::transform_inplace(mask_.begin(), mask_.end(), std::logical_not<bool>());
}

// TODO: Clean this method.
template<class GM, class ACC, class LP, class ILP>
template<class VISITOR>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::performILP
(
	VISITOR &visitor
)
{
	// Do not need to dilate the mask in the newer approach.
	if (parameter_.singleReparametrization_)
		combilp::dilateMask(gm_, mask_);

	Labeling &labeling_lp = labeling_;
	Labeling &lp_labeling = labeling_;

#ifdef OPENGM_COMBILP_DEBUG
	if (!parameter_.singleReparametrization_)
		std::cout << "Applying reparametrization for each ILP run ..." << std::endl;
	else
		std::cout << "Applying a single uniform reparametrization..." << std::endl;
	std::cout << "Switching to ILP." << std::endl;
#endif

	bool startILP=true;
	typename ReparametrizerType::ReparametrizedGMType gm;
	bool reparametrizedFlag=false;
	InferenceTermination terminationId=TIMEOUT;

	for (size_t i=0; (startILP && (i < parameter_.maxNumberOfILPCycles_)); ++i) {
		if(visitor(*this) != visitors::VisitorReturnFlag::ContinueInf)
			return TIMEOUT;

#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "Subproblem " << i << " size=" << std::count(mask_.begin(), mask_.end(), true) << std::endl;
#endif

		MaskType boundmask(mask_.size());
		combilp::getMaskBoundary(gm_, mask_, boundmask);

#ifdef OPENGM_COMBILP_DEBUG
		if (parameter_.saveProblemMasks_) {
			OUT::saveContainer(std::string(parameter_.maskFileNamePre_+"-mask_-"+trws_base::any2string(i)+".txt"),mask_.begin(),mask_.end());
			OUT::saveContainer(std::string(parameter_.maskFileNamePre_+"-boundmask-"+trws_base::any2string(i)+".txt"),boundmask.begin(),boundmask.end());
		}
#endif

		if (parameter_.singleReparametrization_ && (!reparametrizedFlag)) {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Reparametrizing..." << std::endl;
#endif
			MaskType mask(mask_.size(), true);
			reparametrizer_->reparametrize(&mask);
			reparametrizer_->getReparametrizedModel(gm);
			reparametrizedFlag=true;
		} else if (!parameter_.singleReparametrization_) {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Reparametrizing..." << std::endl;
#endif
			reparametrizer_->reparametrize(&mask_);
			reparametrizer_->getReparametrizedModel(gm);
		}

		OPENGM_ASSERT_OP(mask_.size(), ==, gm.numberOfVariables());

		ManipulatorType modelManipulator(gm,ManipulatorType::DROP);
		modelManipulator.unlock();
		modelManipulator.freeAllVariables();

		for (IndexType varId=0;varId<mask_.size();++varId)
			if (mask_[varId]==0)
				modelManipulator.fixVariable(varId,lp_labeling[varId]);

		modelManipulator.lock();

		InferenceTermination terminationILP;
		Labeling labeling;
		terminationILP=PerformILPInference_(modelManipulator, labeling);
		if ((terminationILP != NORMAL) && (terminationILP != CONVERGENCE)) {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "ILP solver failed to solve the problem. Best attained results will be saved." << std::endl;
#endif
			// TODO: BSD: check that in this case the resulting labeling is the
			// best one attained and not obligatory lp_labeling
			if (parameter_.singleReparametrization_)
				labeling_=lp_labeling;

			return terminationILP;
		}

#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "Boundary size=" << std::count(boundmask.begin(),boundmask.end(),true) << std::endl;
#endif

		std::vector<IndexType> result;
		bool optimalityFlag;

		ValueType gap=0;
		if (parameter_.singleReparametrization_) {
			optimalityFlag=combilp::LabelingMatching<GM>(lp_labeling, labeling, boundmask, result);
		} else {
			optimalityFlag=combilp::LabelingMatching(gm, lp_labeling, labeling, mask_, result, gap);
			ValueType newvalue=gm.evaluate(labeling);

			std::vector<bool> imask(mask_.size());
			std::transform(mask_.begin(),mask_.end(),imask.begin(),std::logical_not<bool>());
			ValueType newbound=gm.evaluate(labeling,mask_)+gm.evaluate(labeling,imask);

			if (ACC::bop(newvalue,value_)) {
				value_=newvalue;
				labeling_=labeling;
			}

			ACC::iop(bound_,newbound,bound_);

#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "newvalue=" << newvalue << "; best value=" << value_ << std::endl;
			std::cout << "newbound=" << newbound << "; best bound=" << bound_ << std::endl;
			std::cout << "new gap=" << gap << std::endl;
#endif
		}

		if (optimalityFlag || (fabs(value_-bound_)<= std::numeric_limits<ValueType>::epsilon()*value_)) {
			startILP=false;
			labeling_=labeling;
			value_=bound_=gm_.evaluate(labeling_);
			terminationId=NORMAL;
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Solved! Optimal energy=" << value() << std::endl;
#endif
		} else {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Adding " << result.size() << " nodes." << std::endl;
			if (parameter_.saveProblemMasks_)
			OUT::saveContainer(std::string(parameter_.maskFileNamePre_+"-added-"+trws_base::any2string(i)+".txt"),result.begin(),result.end());
#endif
			for (typename std::vector<IndexType>::const_iterator it=result.begin();it!=result.end();++it) {
				if (parameter_.singleReparametrization_) //BSD: expanding the mask_
					combilp::dilateMask(gm, *it, mask_);
				else
					mask_[*it]=true;
			}
		}
	}

	return terminationId;
}

////////////////////////////////////////////////////////////////////////////////
//
// internal helper functions
//
////////////////////////////////////////////////////////////////////////////////

namespace combilp{

	template<class GM>
	void
	dilateMask
	(
		const GM &gm,
		typename GM::IndexType varId,
		std::vector<bool> &mask
	)
	{
		typedef typename GM::IndexType IndexType;
		typedef typename GM::FactorType FactorType;
		OPENGM_ASSERT_OP(varId, <, gm.numberOfVariables());
		OPENGM_ASSERT_OP(mask.size(), ==, gm.numberOfVariables());

		// Sets all mask for all variables in factor to true.
		typename GM::IndexType numberOfFactors = gm.numberOfFactors(varId);
		for (IndexType i = 0; i < gm.numberOfFactors(varId); ++i) {
			const FactorType &f = gm[ gm.factorOfVariable(varId, i) ];

			for (IndexType j = 0; j < f.numberOfVariables(); ++j)
				mask[ f.variableIndex(j) ] = true;
		}
	}

	template<class GM>
	void
	dilateMask
	(
		const GM &gm,
		std::vector<bool> &mask
	)
	{
		OPENGM_ASSERT_OP(mask.size(), ==, gm.numberOfVariables());
		for (typename GM::IndexType i = 0; i < gm.numberOfVariables(); ++i)
			if (mask[i])
				dilateMask(gm, i, mask);
	}

	// TODO: Needs cleanup.
	template<class GM>
	bool
	LabelingMatching
	(
		const std::vector<typename GM::LabelType> &labeling1,
		const std::vector<typename GM::LabelType> &labeling2,
		const std::vector<bool> &mask,
		std::vector<typename GM::IndexType> &result
	)
	{
		OPENGM_ASSERT_OP(labeling1.size(), ==, mask.size());
		OPENGM_ASSERT_OP(labeling2.size(), ==, mask.size());
		result.clear();
		for (typename GM::IndexType varId = 0;varId < mask.size(); ++varId)
			if ((mask[varId]) && (labeling1[varId] != labeling2[varId]))
				result.push_back(varId);
		return result.empty();
	}

	// TODO: Needs cleanup.
	template<class GM>
	bool
	LabelingMatching(
		const GM &gm,
		const std::vector<typename GM::LabelType> &labeling_out,
		const std::vector<typename GM::LabelType> &labeling_in,
		const std::vector<bool> &mask_in,
		std::vector<typename GM::IndexType> &result,
		typename GM::ValueType& gap
	)
	{
		OPENGM_ASSERT_OP(labeling_in.size(), ==, mask_in.size());
		OPENGM_ASSERT_OP(labeling_out.size(), ==, mask_in.size());
		result.clear();

		//go over all border p/w potentials and check that the corresponding edge 0
		//FIXME: Make types nicer.
		std::vector< std::pair<typename GM::IndexType, typename GM::IndexType> > borderFactors;
		std::vector<typename GM::IndexType> borderFactorCounter(gm.numberOfVariables(),0);//!< is not needed below, just to fit function parameters list
		LPReparametrizer<GM, Minimizer>::getGMMaskBorder(gm, mask_in, &borderFactors, &borderFactorCounter);//!< Minimizer does not play any role in this code, just to instantiate the template

		gap=0;
		std::vector<typename GM::LabelType> ind(2, 0);
		// FIXME: Make types nicer.
		for (typename std::vector<std::pair<typename GM::IndexType,typename GM::IndexType> >::const_iterator fit=borderFactors.begin();
							fit!=borderFactors.end();++fit) {
			typename GM::IndexType var_out=gm[fit->first].variableIndex(fit->second);
			typename GM::IndexType var_in=gm[fit->first].variableIndex(1-fit->second);

			ind[fit->second]=labeling_out[var_out];
			ind[1-fit->second]=labeling_in[var_in];

			if (fabs(gm[fit->first](ind.begin())) > 1e-15)//BSD: improve this line to get an optimal edge and be independent on numerical issues
			{
				gap += gm[fit->first](ind.begin());
				result.push_back(var_out);
			}
		}

		return result.empty();
	}

	template<class GM>
	void
	getMaskBoundary(
		const GM &gm,
		const std::vector<bool> &mask,
		std::vector<bool> &boundmask
	)
	{
		typedef typename GM::IndexType IndexType;
		typedef typename GM::FactorType FactorType;
		OPENGM_ASSERT_OP(mask.size(), ==, gm.numberOfVariables());

		boundmask.assign(mask.size(),false);
		for (IndexType i = 0; i < mask.size(); ++i) {
			if (! mask[i]) continue;

			for (IndexType j = 0; j < gm.numberOfFactors(i); ++j) {
				if (boundmask[j]) break;

				typedef typename FactorType::VariablesIteratorType Iter;
				const FactorType& f = gm[ gm.factorOfVariable(i, j) ];
				for (Iter it = f.variableIndicesBegin(); it != f.variableIndicesEnd(); ++it) {
					if (! mask[*it]) {
						boundmask[i] = true;
						break;
					}
				}
			}
		}
	}
}
}

#endif
